|	Key                 |	Value
1      |	#include <stdio.h>  |	{ #include }
2      |	<stdio.h> #include  |	{ <stdlib.h> }
3      |	#include <stdlib.h> |	{ #include }
4      |	<stdlib.h> #include |	{ <string.h> }
5      |	#include <string.h> |	{ #include }
6      |	<string.h> #include |	{ <time.h> }
7      |	 #include <time.h>  |	{ #include }
8      |	 <time.h> #include  |	{ <math.h> }
9      |	 #include <math.h>  |	{ typedef }
10     |	 <math.h> typedef   |	{ struct }
11     |	  typedef struct    |	{ node , value_node }
12     |	    struct node     |	{ { , *next; }
13     |	      node {        |	{ char }
14     |	      { char        |	{ data[1024]; , c; , temp[1024]; , str[ngram*10]; , str[ngram , temp_2[1000]; , temp_2[1000]; , temp_gram[1000]; }
15     |	 char data[1024];   |	{ struct }
16     |	data[1024]; struct  |	{ node }
17     |	    node *next;     |	{ } }
18     |	     *next; }       |	{ node; }
19     |	      } node;       |	{ typedef }
20     |	   node; typedef    |	{ struct }
21     |	 struct value_node  |	{ { , *nexts; }
22     |	   value_node {     |	{ node }
23     |	      { node        |	{ *value; , *p, , *temp , *temp_check }
24     |	   node *value;     |	{ struct }
25     |	  *value; struct    |	{ value_node }
26     |	value_node *nexts;  |	{ } }
27     |	     *nexts; }      |	{ value_node; }
28     |	   } value_node;    |	{ node }
29     |	 value_node; node   |	{ *words; }
30     |	   node *words;     |	{ node }
31     |	   *words; node     |	{ *linked_list; }
32     |	node *linked_list;  |	{ node }
33     |	*linked_list; node  |	{ *key, }
34     |	    node *key,      |	{ *key1, }
35     |	   *key, *key1,     |	{ *key2; }
36     |	   *key1, *key2;    |	{ value_node }
37     |	 *key2; value_node  |	{ *value, }
38     |	value_node *value,  |	{ *value1, , int }
39     |	 *value, *value1,   |	{ *value2; }
40     |	 *value1, *value2;  |	{ node }
41     |	   *value2; node    |	{ *word_store; }
42     |	 node *word_store;  |	{ node }
43     |	 *word_store; node  |	{ *head_new; }
44     |	  node *head_new;   |	{ node }
45     |	  *head_new; node   |	{ *lines; }
46     |	   node *lines;     |	{ node }
47     |	   *lines; node     |	{ *lines_new; }
48     |	 node *lines_new;   |	{ int }
49     |	  *lines_new; int   |	{ ngram, }
50     |	    int ngram,      |	{ range_key, }
51     |	 ngram, range_key,  |	{ maksimum }
52     |	range_key, maksimum |	{ = }
53     |	    maksimum =      |	{ 0; , 0; , range_value[i]; , max_value(range_value, }
54     |	       = 0;         |	{ char , printf("Reference , printf("'N'-Gram , } , //IO , i , } , j , i , } , } , i , } , break; , while , (y , (y , i , for , s[i]; , for , i , for , w[l]; , i , int , i , i , i , while , if , while , while , while , for , i , while , i , i , i , j }
55     |	      0; char       |	{ **arrKey; }
56     |	  char **arrKey;    |	{ char }
57     |	  **arrKey; char    |	{ **arrKey_temp; }
58     |	char **arrKey_temp; |	{ char }
59     |	**arrKey_temp; char |	{ ***arrValue; }
60     |	 char ***arrValue;  |	{ int }
61     |	 ***arrValue; int   |	{ *range_value; }
62     |	 int *range_value;  |	{ // }
63     |	 *range_value; //   |	{ File }
64     |	      // File       |	{ Setting }
65     |	   File Setting     |	{ FILE }
66     |	   Setting FILE     |	{ *ref_text, }
67     |	  FILE *ref_text,   |	{ *buff, }
68     |	 *ref_text, *buff,  |	{ *result, }
69     |	  *buff, *result,   |	{ *LUT; }
70     |	  *result, *LUT;    |	{ char }
71     |	    *LUT; char      |	{ out_dir[] }
72     |	  char out_dir[]    |	{ = }
73     |	    out_dir[] =     |	{ "text }
74     |	      = "text       |	{ samples/out.txt"; , samples/lut.txt"; , samples/"; , samples/"; }
75     |	"text samples/out.txt";   |	{ char }
76     |	samples/out.txt"; char  |	{ lut_dir[] }
77     |	  char lut_dir[]    |	{ = }
78     |	    lut_dir[] =     |	{ "text }
79     |	"text samples/lut.txt";   |	{ char }
80     |	samples/lut.txt"; char  |	{ file_dir[64] }
81     |	 char file_dir[64]  |	{ = }
82     |	  file_dir[64] =    |	{ "text }
83     |	 "text samples/";   |	{ char , char }
84     |	  samples/"; char   |	{ default_folder[] , filename[64]; }
85     |	char default_folder[]  |	{ = }
86     |	default_folder[] =  |	{ "text }
87     |	char filename[64];  |	{ void }
88     |	filename[64]; void  |	{ red() }
89     |	    void red()      |	{ { }
90     |	      red() {       |	{ printf("\033[1;31m"); }
91     |	{ printf("\033[1;31m");   |	{ } }
92     |	printf("\033[1;31m"); }   |	{ void }
93     |	      } void        |	{ yellow() , blue() , reset() , processing(node , prepare_text(){ , print_ref(){ , print_out() , readFile(node , display(node , display_value(node , display_LUT(node , display_save(node , save_LUT() , output(char , count_value(node , arrBuild() , process(){ }
94     |	   void yellow()    |	{ { }
95     |	    yellow() {      |	{ printf("\033[1;33m"); }
96     |	{ printf("\033[1;33m");   |	{ } }
97     |	printf("\033[1;33m"); }   |	{ void }
98     |	    void blue()     |	{ { }
99     |	     blue() {       |	{ printf("\033[1;34m"); }
100    |	{ printf("\033[1;34m");   |	{ } }
101    |	printf("\033[1;34m"); }   |	{ void }
102    |	   void reset()     |	{ { }
103    |	     reset() {      |	{ printf("\033[0m"); }
104    |	{ printf("\033[0m"); |	{ } }
105    |	printf("\033[0m"); } |	{ int }
106    |	       } int        |	{ isReady(){ , isLUT_ready(){ , key_valid(node , num_Len(int , printRandoms(int , count_key(node , max_value(int }
107    |	  int isReady(){    |	{ int }
108    |	  isReady(){ int    |	{ is }
109    |	      int is        |	{ = , = }
110    |	       is =         |	{ 1; , 0; , 0; , 1; , 0; }
111    |	       = 1;         |	{ buff , if , } , } }
112    |	      1; buff       |	{ = }
113    |	      buff =        |	{ fopen(file_dir, , fopen(file_dir, , fopen(out_dir, }
114    |	 = fopen(file_dir,  |	{ "r"); , "r"); , "r"); }
115    |	fopen(file_dir, "r");  |	{ if , if , c }
116    |	     "r"); if       |	{ (buff , (ref_text }
117    |	     if (buff       |	{ == }
118    |	     (buff ==       |	{ NULL) }
119    |	     == NULL)       |	{ { , { , { , { , { , { , { , { , { , { }
120    |	      NULL) {       |	{ is , r , if , perror("File , for , if , return , printf("%s\n", , if , printf(" , num_len , if , fprintf(LUT, , num_len , tempo , temp , tempo , temp , temp2 , strcpy(temp_gram, , temp_tok , new_node , tempo->value , temp_value , value , range_value[count] , range_value[count] , strcpy(arrKey[counter], , if , strcpy(arrValue[counter][i], }
121    |	       { is         |	{ = , = }
122    |	0; printf("Reference |	{ Text }
123    |	printf("Reference Text  |	{ Not }
124    |	     Text Not       |	{ Exist }
125    |	     Not Exist      |	{ yet }
126    |	     Exist yet      |	{ \n"); }
127    |	     yet \n");      |	{ } }
128    |	      \n"); }       |	{ if }
129    |	       } if         |	{ (ngram , (t_key , (temp_tok , (temp_value , (t , (end }
130    |	     if (ngram      |	{ == }
131    |	     (ngram ==      |	{ 0) }
132    |	       == 0)        |	{ { , { , { , { }
133    |	       0) {         |	{ is , } , return , temp_tok , index_selected[same_1_word] }
134    |	0; printf("'N'-Gram |	{ Not }
135    |	printf("'N'-Gram Not |	{ Set }
136    |	      Not Set       |	{ Yet\n"); }
137    |	   Set Yet\n");     |	{ } }
138    |	    Yet\n"); }      |	{ return }
139    |	     } return       |	{ is; , is; , (1); , (temp); , (temp); , (temp_value); , range_key; , maksimum; }
140    |	    return is;      |	{ } , } }
141    |	       is; }        |	{ int , // }
142    |	int isLUT_ready(){  |	{ int }
143    |	isLUT_ready(){ int  |	{ is }
144    |	       1; if        |	{ (key }
145    |	      if (key       |	{ == }
146    |	      (key ==       |	{ NULL }
147    |	      == NULL       |	{ && }
148    |	      NULL &&       |	{ !isReady()) }
149    |	  && !isReady())    |	{ { }
150    |	   !isReady()) {    |	{ printf("LUT }
151    |	   { printf("LUT    |	{ not }
152    |	  printf("LUT not   |	{ ready }
153    |	     not ready      |	{ yet\n"); }
154    |	  ready yet\n");    |	{ is }
155    |	    yet\n"); is     |	{ = }
156    |	       0; }         |	{ return , //to , j_last , else , //printf("->%s", }
157    |	       } //         |	{ Naoko , Raka }
158    |	     // Naoko       |	{ Punya }
159    |	    Naoko Punya     |	{ void }
160    |	    Punya void      |	{ inverse_node(node }
161    |	void inverse_node(node  |	{ **head) }
162    |	inverse_node(node **head)    |	{ { }
163    |	     **head) {      |	{ node , char }
164    |	     node *p,       |	{ *q, }
165    |	      *p, *q,       |	{ *r; }
166    |	      *q, *r;       |	{ p }
167    |	       *r; p        |	{ = }
168    |	        p =         |	{ q , p->next->next; , p->next; }
169    |	        = q         |	{ = }
170    |	        q =         |	{ r , q->next; , p; }
171    |	        = r         |	{ = }
172    |	        r =         |	{ *head; , q; }
173    |	     = *head;       |	{ p }
174    |	     *head; p       |	{ = }
175    |	 = p->next->next;   |	{ q }
176    |	 p->next->next; q   |	{ = }
177    |	    = q->next;      |	{ r->next }
178    |	 q->next; r->next   |	{ = }
179    |	     r->next =      |	{ NULL; }
180    |	      = NULL;       |	{ q->next , word_store , //read , node , prev , prev->next , node , prev , prev->next , value_node , while , prev , prev->next , tempo_prev , tempo_prev->nexts }
181    |	   NULL; q->next    |	{ = }
182    |	     q->next =      |	{ r; , r; }
183    |	       = r;         |	{ while , } }
184    |	     r; while       |	{ (p }
185    |	     while (p       |	{ != }
186    |	       (p !=        |	{ NULL) }
187    |	     != NULL)       |	{ { , { , { , { , { , { , { , { , { , { , { , { , { , { , { , { , { , { , { , { }
188    |	        { r         |	{ = }
189    |	       = q;         |	{ q , } }
190    |	       q; q         |	{ = }
191    |	       = p;         |	{ p }
192    |	       p; p         |	{ = }
193    |	    = p->next;      |	{ q->next }
194    |	 p->next; q->next   |	{ = }
195    |	       r; }         |	{ *head }
196    |	      } *head       |	{ = }
197    |	      *head =       |	{ q; , word_store; }
198    |	       q; }         |	{ void }
199    |	void processing(node |	{ *head) }
200    |	processing(node *head)  |	{ { }
201    |	     *head) {       |	{ node , while , while }
202    |	    node *temp      |	{ = , = , = }
203    |	      *temp =       |	{ head; , NULL; , NULL; }
204    |	      = head;       |	{ while , node , node }
205    |	    head; while     |	{ (temp->next }
206    |	 while (temp->next  |	{ != }
207    |	  (temp->next !=    |	{ NULL) }
208    |	       { if         |	{ (temp->next->data[0] , (lines->data[j] , (strcmp(data, , (head->next , (head->next , (temp , (temp_tok , (s[i] , (s[l , (strcmp(key_temp[i], , (maksimum , (value2->value->next }
209    |	if (temp->next->data[0]   |	{ == }
210    |	(temp->next->data[0] ==   |	{ 0 }
211    |	       == 0         |	{ || }
212    |	       0 ||         |	{ temp->next->data[0] }
213    |	|| temp->next->data[0]  |	{ == }
214    |	temp->next->data[0] ==  |	{ 9) }
215    |	       == 9)        |	{ { , { }
216    |	       9) {         |	{ temp->next , //puts("a"); }
217    |	   { temp->next     |	{ = }
218    |	   temp->next =     |	{ temp->next->next; , NULL; , NULL; }
219    |	= temp->next->next; |	{ } }
220    |	temp->next->next; } |	{ else }
221    |	      } else        |	{ { , { , if , if , if , { , { , { , { , { , { , { , { , { , { , { }
222    |	      else {        |	{ temp , printf("File , temp[j_last] , temp_check , return , printf(" , fprintf(LUT," , new_node->next , new_node->next , new_node->next , tempo->nexts , fprintf(result,"..."); , strcpy(arrValue[counter][i], }
223    |	      { temp        |	{ = , = , = }
224    |	      temp =        |	{ temp->next; , (node , (node }
225    |	   = temp->next;    |	{ } }
226    |	   temp->next; }    |	{ } }
227    |	        } }         |	{ } , void , void , void , lines , return , void , void , int , void , void , strcpy(temp_2, , if , } , temp2 , a[k++] , if , j , int , int , int , return , void , arrBuild(key2, }
228    |	void prepare_text(){ |	{ printf("File }
229    |	prepare_text(){ printf("File     |	{ Name }
230    |	 printf("File Name  |	{ in }
231    |	      Name in       |	{ Directory }
232    |	   in Directory     |	{ text }
23